<html>
    <head>
        <script src="sigma.min.js"></script>
        <script src="sigma.parsers.gexf.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js" integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0" crossorigin="anonymous"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">
    </head>
    <body>
        <div class="d-flex flex-column align-items-center m-5">
            <h1 class='text-center'>Punggol BTO</h1>
            <div id="sigma-container" style="border: 1px solid black; height: 480px; width:600px;"></div>
        </div>
        <script>
            // Add a method to the graph model that returns an
            // object with every neighbors of a node inside:
            sigma.classes.graph.addMethod('neighbors', function(nodeId) {
              var k,
                  neighbors = {},
                  index = this.allNeighborsIndex[nodeId] || {};
          
              for (k in index)
                neighbors[k] = this.nodesIndex[k];
          
              return neighbors;
            });
          
            sigma.parsers.gexf(
              'PunggolBTO.gexf',
              {
                container: 'sigma-container'
              },
              function(s) {
                // We first need to save the original colors of our
                // nodes and edges, like this:
                s.graph.nodes().forEach(function(n) {
                  n.originalColor = n.color;
                });
                s.graph.edges().forEach(function(e) {
                  e.originalColor = e.color;
                });
          
                // When a node is clicked, we check for each node
                // if it is a neighbor of the clicked one. If not,
                // we set its color as grey, and else, it takes its
                // original color.
                // We do the same for the edges, and we only keep
                // edges that have both extremities colored.
                s.bind('clickNode', function(e) {
                  var nodeId = e.data.node.id,
                      toKeep = s.graph.neighbors(nodeId);
                  toKeep[nodeId] = e.data.node;
          
                  s.graph.nodes().forEach(function(n) {
                    if (toKeep[n.id])
                      n.color = n.originalColor;
                    else
                      n.color = '#eee';
                  });
          
                  s.graph.edges().forEach(function(e) {
                    if (toKeep[e.source] && toKeep[e.target])
                      e.color = e.originalColor;
                    else
                      e.color = '#eee';
                  });
          
                  // Since the data has been modified, we need to
                  // call the refresh method to make the colors
                  // update effective.
                  s.refresh();
                });
          
                // When the stage is clicked, we just color each
                // node and edge with its original color.
                s.bind('clickStage', function(e) {
                  s.graph.nodes().forEach(function(n) {
                    n.color = n.originalColor;
                  });
          
                  s.graph.edges().forEach(function(e) {
                    e.color = e.originalColor;
                  });
          
                  // Same as in the previous event:
                  s.refresh();
                });
              }
            );
          </script>
    </body>
</html>